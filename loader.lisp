(in-package :sento-user)
(defun find-cves (dir-path)
  "Recursively finds all .json files under the given directory path."
  (directory (merge-pathnames "*/*/*.json" dir-path)))

(defun fixup-dirname (str)
  (if (not (string-suffix-p "/" str))
      (concatenate 'string str "/")
      str))

(defun make-series (num-str)
  (let* ((len (length num-str))
         (start (- len 3))
         (prefix (subseq num-str 0 start))
         (suffix "xxx"))
    (concatenate 'string prefix suffix)))

(defun find-cve (str root)
    (format t "Merging..")
  (let* ((parts (uiop:split-string str :separator "-"))
         (year (nth 1 parts))
         (series (make-series (nth 2 parts)))
         (dir (make-pathname :directory (list :absolute root year series))))
    (uiop:merge-pathnames* dir (concatenate 'string (string-upcase str) ".json"))))

(defun walk-json (jdata path)
  "Get keys recursivly in path."
  (cond ((null path) jdata)
      ((not (listp jdata)) nil)
      (t (walk-json (jsown:val jdata (car path)) (cdr path)))))

(defun walk-json-safe (jdata path &optional (default nil))
  "Get keys recursively in path, with error handling and an optional default value."
  (handler-case
      (cond ((null path) jdata)
            ((not (listp jdata)) default)
            (t (walk-json-safe (jsown:val jdata (car path)) (cdr path) default)))
    (error (e)
      default)))


(defun status-affected-p (jdata)
  (let ((status (jsown:val jdata "status")))
    (string-equal (string-downcase status) "affected")))

(defun state-rejected-p (jdata)
  (let ((state (walk-json jdata '("cveMetadata" "state"))))
    (string-equal (string-downcase state) "rejected")))


(defun fixup-cve (path)
  (let* ((data (uiop:read-file-string path))
         (jdata (jsown:parse data))
         (cve-id (walk-json-safe jdata '("cveMetadata" "cveId"))))
         
    (if (null ())
        (print path))
    (if (not (state-rejected-p jdata))
        (progn

          (jsown:new-js
            ("_id" cve-id)
            ("date-created" (walk-json-safe jdata '("cveMetadata" "dateReserved")))
            ("date-updated" (walk-json-safe jdata '("cveMetadata" "dateUpdated")))
            ("date-published" (walk-json-safe jdata '("cveMetadata" "datePublished")))
            ("state" (walk-json jdata '("cveMetadata" "state")))
            ("description" (mapcar (lambda (data)
                                     (jsown:val data "value"))
                                   (walk-json jdata '("containers" "cna" "descriptions"))))
            ("affected" (walk-json jdata '("containers" "cna" "affected")))
            ("references" (mapcar (lambda (data)
                                    (jsown:val data "url"))
                                  (walk-json jdata '("containers" "cna" "references"))))
            ("problem-types" (mapcar (lambda (data) (walk-json-safe jdata '("descriptions" "description")))

                                     (walk-json-safe jdata '("containers" "cna" "problemTypes"))))
            ("metrics" (jsown:val-safe (jsown:val-safe (jsown:val-safe jdata "containers") "cna") "metrics"))))


        (progn
          (jsown:new-js
            ("_id" cve-id)
            ("state" "rejected")
            ("date-created" (walk-json-safe jdata '("cveMetadata" "dateReserved")))
            ("date-updated" (walk-json-safe jdata '("cveMetadata" "dateUpdated")))
            ("date-published" (walk-json-safe jdata '("cveMetadata" "datePublished")))
            ("description" (mapcar (lambda (data)
                                     (jsown:val data "value"))

                                   (walk-json jdata '("containers" "cna" "rejectedReasons")))))))))

(defun distribute (lst n)
  "Split a list LST into sublists of size N."
  (loop for i from 0 below (length lst) by n
        collect (subseq lst i (min (+ i n) (length lst)))))



(defun partition-list (list parts &key (last-part-longer nil))
  ;; Partition LIST into PARTS parts.  They will all be the same
  ;; length except the last one which will be shorter or, if
  ;; LAST-PART-LONGER is true, longer.  Doesn't deal with the case
  ;; where there are less than PARTS elements in LIST at all (it does
  ;; something, but it may not be sensible).
  (loop with size = (if last-part-longer
                        (floor (length list) parts)
                        (ceiling (length list) parts))
        and tail = list
        for part upfrom 1
        while tail
        collect (loop for pt on tail
                      for i upfrom 0
                      while (or (and last-part-longer (= part parts))
                                (< i size))
                      collect (first pt)
                      finally (setf tail pt))))

;; (actor-of *system* :name "import"
;;                    :receive
;;           (lambda (msg)
;;             (if msg
;;                 (progn
;;                   (let ((db (get-db)))
;;                     (loop for chunk in))))))
(defun bulk-load (dir)
  (let ((files (distribute (find-cves dir) 500))
        (data ()))
    (loop for outer in files
          do
             (setf data ())
             (loop for inner in outer
                   do
                      (handler-case
                          (progn
                            ;; (info>
                            ;;  (new-message "Parsing {{data}}" :args (list `("data" . ,inner))))
                            (push (fixup-cve inner) data))
                            ;; (info>
                            ;;  (newmessage "Parsed {{data}}" :args  (list `("data" . ,inner))))

                        (error (e)
                          (warning> (new-message "Failed to parse CVE data. {{e}}" :args  (list `("e" . ',e)))))))


             (? *bulk-inserts* (jsown:to-json (jsown:new-js ("docs" data)))))))
